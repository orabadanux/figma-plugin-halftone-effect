<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Halftone Effect Plugin UI</title>
    <!-- Tailwind CSS via CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      .spinner {
        border: 4px solid rgba(0,0,0,0.1);
        border-left-color: #000000;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body class="bg-gray-50">
    <div id="root" class="max-w-xl mx-auto p-4">
      <h1 class="text-2xl font-bold mb-4">Halftone Effect Plugin UI</h1>
      <!-- Loader element; will remain until the image is loaded -->
      <div id="loader" class="flex items-center justify-center h-20">
        <div class="spinner"></div>
        <span class="ml-2">Loading...</span>
      </div>
      <div id="placeholder" class="text-gray-600">No image selected.</div>
    </div>

    <script>
      // --- Inlined UI Logic for Figma Plugin with Tailwind, Loader, and Controls ---

      // Global variables for image and UI elements
      let originalImage = null;
      let canvas, ctx;
      let sliderGrid, selectShape, colorPicker, btnGenerate;
      const shapes = ["Circle", "Square", "Cross"];

      // Function to set up the UI once an image is loaded.
      // This function will remove the loader and placeholder and then create the canvas and controls.
      function setupUI() {
        const root = document.getElementById("root");

        // Remove loader and placeholder if present.
        const loader = document.getElementById("loader");
        if (loader) loader.remove();
        const placeholder = document.getElementById("placeholder");
        if (placeholder) placeholder.remove();

        // Create canvas.
        const canvasEl = document.createElement("canvas");
        canvasEl.id = "previewCanvas";
        canvasEl.className = "border border-gray-300 mb-4 w-full";
        root.appendChild(canvasEl);
        canvas = canvasEl;
        ctx = canvas.getContext("2d");

        // Create controls container.
        const controls = document.createElement("div");
        controls.id = "controls";
        controls.className = "space-y-4";

        // Grid Size slider (range 1-50)
        const gridContainer = document.createElement("div");
        gridContainer.className = "slider-container";
        const labelGrid = document.createElement("label");
        labelGrid.className = "block font-medium";
        labelGrid.innerText = "Grid Size";
        sliderGrid = document.createElement("input");
        sliderGrid.id = "gridSlider";
        sliderGrid.type = "range";
        sliderGrid.min = "1";
        sliderGrid.max = "50";
        sliderGrid.value = "10";
        sliderGrid.className = "w-full";
        gridContainer.appendChild(labelGrid);
        gridContainer.appendChild(sliderGrid);
        controls.appendChild(gridContainer);

        // Combined row for Dot Shape and Dot Color.
        const combinedRow = document.createElement("div");
        combinedRow.className = "flex flex-row items-center space-x-4";

        // Dot Shape dropdown.
        const shapeContainer = document.createElement("div");
        shapeContainer.className = "flex-1";
        const labelShape = document.createElement("label");
        labelShape.className = "block font-medium";
        labelShape.innerText = "Dot Shape";
        selectShape = document.createElement("select");
        selectShape.id = "shapeSelect";
        selectShape.className = "w-full p-2 border border-gray-300 rounded";
        shapes.forEach((s) => {
          const opt = document.createElement("option");
          opt.value = s;
          opt.innerText = s;
          selectShape.appendChild(opt);
        });
        shapeContainer.appendChild(labelShape);
        shapeContainer.appendChild(selectShape);
        combinedRow.appendChild(shapeContainer);

        // Dot Color picker.
        const colorContainer = document.createElement("div");
        colorContainer.className = "flex-1";
        const labelColor = document.createElement("label");
        labelColor.className = "block font-medium";
        labelColor.innerText = "Dot Color";
        colorPicker = document.createElement("input");
        colorPicker.id = "colorPicker";
        colorPicker.type = "color";
        colorPicker.value = "#000000";
        colorPicker.className = "w-full h-12 p-0 border-none";
        colorContainer.appendChild(labelColor);
        colorContainer.appendChild(colorPicker);
        combinedRow.appendChild(colorContainer);

        controls.appendChild(combinedRow);

        // Generate button.
        btnGenerate = document.createElement("button");
        btnGenerate.id = "generateBtn";
        btnGenerate.innerText = "Generate";
        btnGenerate.className = "bg-blue-500 text-white py-2 px-4 rounded w-full";
        controls.appendChild(btnGenerate);

        root.appendChild(controls);

        // Add event listeners.
        [sliderGrid, selectShape, colorPicker].forEach((control) => {
          control.addEventListener("input", updateCanvas);
        });
        btnGenerate.addEventListener("click", () => {
          const dataURL = canvas.toDataURL("image/png").split(",")[1];
          parent.postMessage({ pluginMessage: { type: "apply-effect", imageData: dataURL } }, "*");
        });
      }

      // Function to update the canvas with a basic halftone effect using only grid size.
      function updateCanvas() {
        if (!originalImage || !canvas || !ctx) return;
        canvas.width = originalImage.width;
        canvas.height = originalImage.height;

        // Draw original image to get pixel data.
        ctx.drawImage(originalImage, 0, 0);
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const gridSize = Number(sliderGrid.value);
        const maxRadius = gridSize / 2;
        const shape = selectShape.value; // "Circle", "Square", "Cross"
        const dotColor = colorPicker.value; // e.g., "#000000"

        for (let y = 0; y < canvas.height; y += gridSize) {
          for (let x = 0; x < canvas.width; x += gridSize) {
            let totalLum = 0;
            let validCount = 0;
            for (let j = 0; j < gridSize; j++) {
              for (let i = 0; i < gridSize; i++) {
                const px = x + i;
                const py = y + j;
                if (px < canvas.width && py < canvas.height) {
                  const idx = (py * canvas.width + px) * 4;
                  const r = imgData.data[idx];
                  const g = imgData.data[idx + 1];
                  const b = imgData.data[idx + 2];
                  const a = imgData.data[idx + 3];
                  if (a >= 128) { // Only consider opaque pixels.
                    const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                    totalLum += lum;
                    validCount++;
                  }
                }
              }
            }
            if (validCount === 0) continue;
            const avgLum = totalLum / validCount;
            const radius = maxRadius * (1 - avgLum / 255);
            if (radius < 0.5) continue;

            ctx.fillStyle = dotColor;
            const centerX = x + gridSize / 2;
            const centerY = y + gridSize / 2;
            if (shape === "Circle") {
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
              ctx.fill();
            } else if (shape === "Square") {
              const side = radius * 2;
              ctx.fillRect(centerX - radius, centerY - radius, side, side);
            } else if (shape === "Cross") {
              const barWidth = radius / 2;
              ctx.fillRect(centerX - radius, centerY - barWidth / 2, radius * 2, barWidth);
              ctx.fillRect(centerX - barWidth / 2, centerY - radius, barWidth, radius * 2);
            }
          }
        }
      }

      // Listen for messages from code.ts
      window.onmessage = (event) => {
        const msg = event.data.pluginMessage;
        console.log("UI received message:", msg);
        if (msg.type === "load-image") {
          const imageDataURL = "data:image/png;base64," + msg.data;
          const img = new Image();
          // Show loader until the image loads
          // (The initial HTML already shows the loader.)
          img.onload = () => {
            originalImage = img;
            setupUI();
            updateCanvas();
          };
          img.src = imageDataURL;
        } else if (msg.type === "no-image") {
          document.getElementById("root").innerText = "Select an image.";
        }
      };

      console.log("UI script loaded");
    </script>
  </body>
</html>
